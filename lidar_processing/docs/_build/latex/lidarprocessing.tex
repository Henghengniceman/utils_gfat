% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\title{lidar processing Documentation}
\date{Sep 27, 2016}
\release{0.1.0}
\author{Ioannis Binietoglou}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Introduction}
\label{introduction:introduction}\label{introduction:welcome-to-lidar-processing-s-documentation}\label{introduction::doc}
This module collects basic processing routines for aerosol lidar systems. Its aim is to act as a repository
of pre-processing and optical processing routines, that can be used as a basic building block for any atmospheric
lidar processing software.

To make it reusable, the module includes only the pre-processing and optical processing functions.
Reading data, visualization, etc. should be handled by different modules.

\begin{notice}{note}{Note:}
Here is a list of complementary lidar-related modules:
\begin{description}
\item[{Molecular scattering}] \leavevmode
The \href{https://bitbucket.org/iannis\_b/lidar\_molecular}{lidar\_molecular}  module is a collection of scripts to calculate
scattering parameters of molecular atmosphere.

\item[{Raw lidar files}] \leavevmode
The \href{https://bitbucket.org/iannis\_b/atmospheric-lidar}{atmospheric-lidar} module contains classes to read raw lidar
data files, including Licel binary files. It can be used for plotting (quicklooks) and converting raw data to
SCC format.

\item[{EARLINET optical file reader}] \leavevmode
The \href{https://bitbucket.org/iannis\_b/earlinet-optical-file-reader}{earlinet files} files can be use to \emph{read} and
plot aerosol properties stored in the EARLINET netdf file format.

\end{description}
\end{notice}


\section{Installation}
\label{introduction:installation}
The module is tested against Python 2.7.*

The code is developed using the mercurial version control software. The repository is hosted on
\href{https://bitbucket.org/iannis\_b/lidar\_processing}{bitbucket}.

\begin{notice}{note}{Note:}
For an introduction to mercurial version control software check out \url{http://hginit.com/}.

If you prefer to use a program with GUI, try using \href{http://easyhg.org/}{Easy mercurial}.
\end{notice}

The suggested method to install is to clone the repository and install it using the -e command.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+go}{pip install \PYGZhy{}e ./lidar\PYGZus{}processing}
\end{Verbatim}

assuming that the module is cloned in the lidar\_processing directory.

The installation procedure is not yet fully automatic. You will need to install manually: numpy, scipy, and
the \href{https://bitbucket.org/iannis\_b/lidar\_molecular}{lidar\_molecular} module. The best way to install numpy and scipy
is through a distribution like \href{https://www.continuum.io/downloads}{anaconda}.

When this and the \emph{molecular} modules mature, we should optimize the installation procedure.


\section{Documentation}
\label{introduction:documentation}
Each function should be documented following the Numpy doc style.

For details see the \href{https://github.com/numpy/numpy/blob/master/doc/HOWTO\_DOCUMENT.rst.txt}{numpy documentation}.

All docstrings are collected to a single documentation file using the \href{http://www.sphinx-doc.org/}{Sphinx} module.
The documentation is located in the docs/ folder. The documentation is written in
\href{http://www.sphinx-doc.org/en/stable/rest.html}{restructured text} format.

You can rebuild the docs by running the following command from the docs folder.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+go}{make html}
\end{Verbatim}

The documentation is also built automatically every time you push your changes to the repository. You can find it online
in \href{https://readthedocs.org/projects/lidar-processing/}{Read the docs}.


\section{Testing}
\label{introduction:testing}
Some tests, based on unittest2 library, are located in the lidar\_processing/tests/ folder.

You can run all the test using the commands from the project directory.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+go}{python \PYGZhy{}m unittest discover}
\end{Verbatim}


\section{Todo}
\label{introduction:todo}
The module is still in a very early stage so most things need to be done. Here is an indicative list of things to add:
\begin{itemize}
\item {} 
Signal gluing

\item {} 
Optical product gluing (e.g. from near and far range telescopes).

\item {} 
Error propagation (Monte Carlo method).

\item {} 
Klett algorithm for elastic lidar retrieval

\item {} 
Raman scattering algorithms for backscatter and extinction.

\end{itemize}

Even if you don't have something to code, there are other ways to contribute, e.g:
\begin{itemize}
\item {} 
Review/improve this documentation.

\item {} 
Test that the implemented functions work correctly.

\item {} 
Suggest missing routines or other improvements.

\end{itemize}


\chapter{Pre processing functions}
\label{pre_processing:pre-processing-functions}\label{pre_processing::doc}\label{pre_processing:module-pre_processing}\index{pre\_processing (module)}
Summer school test.

Function for preprocessing lidar signals.

\begin{notice}{note}{Todo}

Decide how to handle error propagation. Current plan is to estimate errors using end-to-end Monte Carlo
simulations (not implemented yet), instead of  calculating errors in every step.
\end{notice}
\index{apply\_range\_correction() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.apply_range_correction}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{apply\_range\_correction}}{\emph{signal}, \emph{altitude}}{}
Apply range correction, i.e. multiply with z\textasciicircum{}2.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal: array}
\begin{quote}

The input signal array
\end{quote}

\textbf{altitude: array}
\begin{quote}

The altitude array. It should be the same size as the signal.
\end{quote}

\item[{Returns}] \leavevmode
rcs: array
\begin{quote}

The range corrected signal.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{bin\_array() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.bin_array}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{bin\_array}}{\emph{array}, \emph{bins}}{}
Performs a binning (averaging) of the array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{array: array}
\begin{quote}

Input array
\end{quote}

\textbf{bins:}
\begin{quote}

The number of bins to average.
\end{quote}

\item[{Returns}] \leavevmode
binned\_array: array
\begin{quote}

The binned array.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{correct\_dead\_time\_nonparalyzable() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.correct_dead_time_nonparalyzable}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{correct\_dead\_time\_nonparalyzable}}{\emph{signal}, \emph{measurement\_interval}, \emph{dead\_time}}{}
Apply non-paralizable dead time correction.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal: integer array}
\begin{quote}

The measured number on photons
\end{quote}

\textbf{measurement\_interval: float}
\begin{quote}

The total measurement interval in ns
\end{quote}

\textbf{dead\_time: float}
\begin{quote}

The detector system dead time in ns
\end{quote}

\item[{Returns}] \leavevmode
corrected\_signal: float array
\begin{quote}

The true number of photons arriving at the detector
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{correct\_dead\_time\_paralyzable() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.correct_dead_time_paralyzable}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{correct\_dead\_time\_paralyzable}}{\emph{signal}, \emph{measurement\_interval}, \emph{dead\_time}}{}
Apply paralyzable dead time correction.

For a paralyzable system, each measurement corresponds to two possible real
values. The solution offered here corresponds to the first branch {[}0, measurement\_interval / dead\_time{]}

The solution uses a L-BFGS-B algorithm for optimization.

\begin{notice}{note}{Note:}
If you use this routine you should cite oneof the papers of the original authors.
See the \href{http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin\_l\_bfgs\_b.html}{scipy} website
for details.
\end{notice}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal: integer array}
\begin{quote}

The measured number on photons
\end{quote}

\textbf{measurement\_interval: float}
\begin{quote}

The total measurement interval in ns
\end{quote}

\textbf{dead\_time: float}
\begin{quote}

The detector system dead time in ns
\end{quote}

\item[{Returns}] \leavevmode
corrected\_signal: float array
\begin{quote}

The true number of photons arriving at the detector
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{correct\_dead\_time\_polynomial\_count\_rate() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.correct_dead_time_polynomial_count_rate}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{correct\_dead\_time\_polynomial\_count\_rate}}{\emph{signal}, \emph{coefficients}}{}
Correct dead time using a polynomial.

The coefficients will be passed to numpy.pollyval, so they should be order from higher to lower like
p{[}0{]}*x**(N-1) + p{[}1{]}*x**(N-2) + ... + p{[}N-2{]}*x + p{[}N-1{]}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal: integer array}
\begin{quote}

The measured count rate in MHz
\end{quote}

\textbf{coefficients: list}
\begin{quote}

A list of polynomial coefficients for the correction
\end{quote}

\item[{Returns}] \leavevmode
corrected\_signal: float array
\begin{quote}

The true number of photons arriving at the detector
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}

The method is described in
Engelmann, R. et al.: The automated multiwavelength Raman polarization and water-vapor lidar PollyXT:
the neXT generation, Atmos. Meas. Tech., 9, 1767-1784, doi:10.5194/amt-9-1767-2016, 2016.

\end{fulllineitems}

\index{correct\_dead\_time\_polynomial\_counts() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.correct_dead_time_polynomial_counts}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{correct\_dead\_time\_polynomial\_counts}}{\emph{signal}, \emph{coefficients}, \emph{measurement\_interval}}{}
Correct dead time using a polynomial.

The coefficients will be passed to numpy.pollyval, so they should be order from higher to lower like
p{[}0{]}*x**(N-1) + p{[}1{]}*x**(N-2) + ... + p{[}N-2{]}*x + p{[}N-1{]}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal: integer array}
\begin{quote}

The measured number on photons
\end{quote}

\textbf{coefficients: list}
\begin{quote}

A list of polynomial coefficients for the correction
\end{quote}

\textbf{measurement\_interval: float}
\begin{quote}

The total measurement interval in ns
\end{quote}

\item[{Returns}] \leavevmode
corrected\_signal: float array
\begin{quote}

The true number of photons arriving at the detector
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}

The method is described in
Engelmann, R. et al.: The automated multiwavelength Raman polarization and water-vapor lidar PollyXT:
the neXT generation, Atmos. Meas. Tech., 9, 1767-1784, doi:10.5194/amt-9-1767-2016, 2016.

\end{fulllineitems}

\index{correct\_overlap() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.correct_overlap}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{correct\_overlap}}{\emph{signal}, \emph{overlap\_array=None}, \emph{full\_overlap\_idx=None}}{}
Corrects the signal for a give overlap function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal: int or float array}
\begin{quote}

The lidar signal profile.
\end{quote}

\textbf{overlap\_array: int or float array}
\begin{quote}

An array containing the overlap function (from 0 to 1)
\end{quote}

\textbf{full\_overlap\_idx: int}
\begin{quote}

Index of full overlap. If specified, all values above this index are considered 1.
\end{quote}

\textbf{-------}

\textbf{Returns}

\textbf{corrected\_signal: array}
\begin{quote}

The overlap-corrected signal.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{correct\_trigger\_delay\_bins() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.correct_trigger_delay_bins}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{correct\_trigger\_delay\_bins}}{\emph{signal}, \emph{trigger\_delay\_bins}}{}
Shifts the signal for one channel by a specified number of bins.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal: float array}
\begin{quote}

The lidar signal profile
\end{quote}

\textbf{trigger\_delay\_bins: int}
\begin{quote}

Number of bins to shift the signal
\end{quote}

\item[{Returns}] \leavevmode
signal: float array
\begin{quote}

Corrected lidar signal profile (shifted)
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}

The number of bins to be shifted should be positive. For negative values
the shift will be done in reverse.

\end{fulllineitems}

\index{correct\_trigger\_delay\_ns() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.correct_trigger_delay_ns}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{correct\_trigger\_delay\_ns}}{\emph{signal}, \emph{altitude}, \emph{trigger\_delay\_ns}}{}
Corrects the trigger delay for one channel for trigger delay smaller than
the difference between 2 neighboring bins.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal: int or float array}
\begin{quote}

The lidar signal profile
\end{quote}

\textbf{altitude: float array}
\begin{quote}

Altitude array {[}m{]}
\end{quote}

\textbf{trigger\_delay\_ns} : float
\begin{quote}

Trigger delay value of the channel {[}ns{]}
\end{quote}

\item[{Returns}] \leavevmode
corrected\_signal: int or float array
\begin{quote}

Corrected signal (shifted and interpolated to the initial altitude values)
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{counts\_to\_rate() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.counts_to_rate}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{counts\_to\_rate}}{\emph{signal}, \emph{measurement\_interval=0.00015000000000000001}}{}
Transform signal from counts to count rate.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal: array}
\begin{quote}

The input signal array
\end{quote}

\textbf{measurement\_interval: float}
\begin{quote}

The total measurement interval in s
\end{quote}

\item[{Returns}] \leavevmode
rate: array
\begin{quote}

Count rate signal
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_gluing\_candidates() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.get_gluing_candidates}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{get\_gluing\_candidates}}{\emph{lower\_signal}, \emph{upper\_signal}, \emph{window\_length}, \emph{correlation\_threshold}, \emph{intercept\_threshold}, \emph{gaussian\_threshold}, \emph{minmax\_threshold}}{}
Return a boolean array with points that satisfy the specified gluing criteria.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{lower\_signal: array}
\begin{quote}

The low-range signal to be used.
\end{quote}

\textbf{upper\_signal: array}
\begin{quote}

The high-range signal to be used.
\end{quote}

\textbf{window\_length: int}
\begin{quote}

The number of bins to be used for gluing
\end{quote}

\textbf{correlation\_threshold: float}
\begin{quote}

Threshold for the correlation coefficient
\end{quote}

\textbf{intercept\_threshold:}
\begin{quote}

Threshold for the linear fit intercept
\end{quote}

\textbf{gaussian\_threshold:}
\begin{quote}

Threshold for the Shapiro-Wilk p-value.
\end{quote}

\textbf{minmax\_threshold:}
\begin{quote}

Threshold for the min/max ratio.
\end{quote}

\item[{Returns}] \leavevmode
gluing\_candidates: boolean array
\begin{quote}

An array with True where the gluing criteria are satisfied.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_gluing\_score() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.get_gluing_score}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{get\_gluing\_score}}{\emph{lower\_signal}, \emph{upper\_signal}, \emph{window\_length}}{}
Calculate the gluing score.

\end{fulllineitems}

\index{glue\_signals() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.glue_signals}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{glue\_signals}}{\emph{lower\_signal}, \emph{upper\_signal}, \emph{window\_length=200}, \emph{correlation\_threshold=0.95}, \emph{intercept\_threshold=0.5}, \emph{gaussian\_threshold=0.2}, \emph{minmax\_threshold=0.5}, \emph{min\_idx=None}, \emph{max\_idx=None}, \emph{use\_upper\_as\_reference=True}}{}
Automatically glue two signals.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{lower\_signal: array}
\begin{quote}

The low-range signal to be used.
\end{quote}

\textbf{upper\_signal: array}
\begin{quote}

The high-range signal to be used.
\end{quote}

\textbf{window\_length: int}
\begin{quote}

The number of bins to be used for gluing
\end{quote}

\textbf{correlation\_threshold: float}
\begin{quote}

Threshold for the correlation coefficient
\end{quote}

\textbf{intercept\_threshold:}
\begin{quote}

Threshold for the linear fit intercept
\end{quote}

\textbf{gaussian\_threshold:}
\begin{quote}

Threshold for the Shapiro-Wilk p-value.
\end{quote}

\textbf{minmax\_threshold:}
\begin{quote}

Threshold for the min/max ratio
\end{quote}

\textbf{min\_idx, max\_idx: int}
\begin{quote}

Minimum and maximum index to search for a gluing region.
\end{quote}

\textbf{use\_upper\_as\_reference: bool}
\begin{quote}

If True, the upper signal is used as reference. Else, the lower signal is used.
\end{quote}

\item[{Returns}] \leavevmode
glued\_signal: array
\begin{quote}

The glued signal array, same size as lower\_signal and upper\_signal.
\end{quote}

gluing\_center\_idx: int
\begin{quote}

Index choses to perform gluing.
\end{quote}

gluing\_score: float
\begin{quote}

The gluing score at the chosen point.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{glue\_signals\_at\_bins() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.glue_signals_at_bins}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{glue\_signals\_at\_bins}}{\emph{lower\_signal}, \emph{upper\_signal}, \emph{min\_bin}, \emph{max\_bin}, \emph{use\_upper\_as\_reference=True}}{}
Glue two signals at a given bin range. No checks are performed.

Both signals are assumed to have the same altitude grid. The final glued signal is calculated
performing a linear fade-in/fade-out operation in the glue region.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{lower\_signal: array}
\begin{quote}

The low-range signal to be used.
\end{quote}

\textbf{upper\_signal: array}
\begin{quote}

The high-range signal to be used.
\end{quote}

\textbf{min\_bin: int}
\begin{quote}

The lower bin to perform the gluing
\end{quote}

\textbf{max\_bin: int}
\begin{quote}

The upper bin to perform the gluing
\end{quote}

\textbf{use\_upper\_as\_reference: bool}
\begin{quote}

If True, the upper signal is used as reference. Else, the lower signal is used.
\end{quote}

\item[{Returns}] \leavevmode
glued\_signal: array
\begin{quote}

The glued signal array, same size as lower\_signal and upper\_signal.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{rate\_to\_counts() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.rate_to_counts}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{rate\_to\_counts}}{\emph{signal}, \emph{measurement\_interval=0.00015000000000000001}}{}
Transform signal from count rate to counts.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal: array}
\begin{quote}

The input signal array
\end{quote}

\textbf{measurement\_interval: float}
\begin{quote}

The total measurement interval in s
\end{quote}

\item[{Returns}] \leavevmode
counts: array
\begin{quote}

Counts signal
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{subtract\_background() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.subtract_background}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{subtract\_background}}{\emph{signal}, \emph{idx\_min}, \emph{idx\_max}}{}
Subtracts the background level from the signal.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal: float vector}
\begin{quote}

The lidar signal vertical profile.
\end{quote}

\textbf{idx\_min: integer}
\begin{quote}

The minimum index to calculate the background level
\end{quote}

\textbf{idx\_max: integer}
\begin{quote}

The maximum index to calculate the background level
\end{quote}

\item[{Returns}] \leavevmode
corrected\_signal: float array
\begin{quote}

The signal without the background level
\end{quote}

background\_mean: float
\begin{quote}

The mean value of the background
\end{quote}

background\_std:
\begin{quote}

The standard deviation of the background
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{subtract\_electronic\_background() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.subtract_electronic_background}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{subtract\_electronic\_background}}{\emph{signal}, \emph{background\_signal}}{}
Subtract the electronic background profile from the signal.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal: int or float array}
\begin{quote}

The lidar signal profile.
\end{quote}

\textbf{background\_signal: int or float array}
\begin{quote}

Electronic background profile. It should be the same dimension as the signal array.
\end{quote}

\item[{Returns}] \leavevmode
output\_singal: array
\begin{quote}

The array with the corrected signal.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{trigger\_delay\_to\_bins() (in module pre\_processing)}

\begin{fulllineitems}
\phantomsection\label{pre_processing:pre_processing.trigger_delay_to_bins}\pysiglinewithargsret{\sphinxcode{pre\_processing.}\sphinxbfcode{trigger\_delay\_to\_bins}}{\emph{trigger\_delay\_ns}, \emph{altitude\_resolution}}{}
Calculates the integer and fractional part of the trigger delay altitude shift.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{trigger\_delay\_ns: float}
\begin{quote}

Trigger delay value of the channel {[}ns{]}
\end{quote}

\textbf{altitude\_resolution: float}
\begin{quote}

Altitude resolution of the lidar {[}m{]}
\end{quote}

\item[{Returns}] \leavevmode
integer\_bins: int
\begin{quote}

Part of the trigger delay in meters that is equal to a multiple of
the altitude resolution
\end{quote}

fraction\_bins: float
\begin{quote}

The fractional part of the trigger delay in meters
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}

This function can be used to divide the trigger delay so that the integer
part can be solved with correct\_trigger\_delay\_bins() and the fractional part
with correct\_trigger\_delay\_ns(). It is required for trigger delay error 
propagation in the case of interpolation.

\end{fulllineitems}



\chapter{Checks for fitting singals}
\label{fit_checks:checks-for-fitting-singals}\label{fit_checks::doc}\label{fit_checks:module-fit_checks}\index{fit\_checks (module)}
This file contains functions that check if two signals fit or not. They can be used to check a
gluing or molecular fit regions.
\index{check\_correlation() (in module fit\_checks)}

\begin{fulllineitems}
\phantomsection\label{fit_checks:fit_checks.check_correlation}\pysiglinewithargsret{\sphinxcode{fit\_checks.}\sphinxbfcode{check\_correlation}}{\emph{first\_signal}, \emph{second\_signal}, \emph{threshold=None}}{}
Returns the correlation coefficient between the two signals.

The signals can be either 1D arrays or 2D arrays containing the rolling slices
of the input signals. In the 2D case, the function returns the sliding correlation
between the original signals.

If a threshold is provided, returns True if
the correlation is above the specified threshold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{first\_signal: array}
\begin{quote}

The first signal array
\end{quote}

\textbf{second\_signal: array}
\begin{quote}

The second signal array
\end{quote}

\textbf{threshold: float or None}
\begin{quote}

Threshold for the correlation coefficient.
\end{quote}

\item[{Returns}] \leavevmode
correlation: float or boolean
\begin{quote}

If threshold is None, then the function returns an the correlation coefficient.
If a threshold is provided, the function returns True if the correlation value is
above the threshold.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_linear\_fit\_intercept() (in module fit\_checks)}

\begin{fulllineitems}
\phantomsection\label{fit_checks:fit_checks.check_linear_fit_intercept}\pysiglinewithargsret{\sphinxcode{fit\_checks.}\sphinxbfcode{check\_linear\_fit\_intercept}}{\emph{first\_signal}, \emph{second\_signal}, \emph{threshold=None}}{}
Check if the intercept of a linear fit is near zero.

Performs a linear fit to the data, assuming y = ax + b, with x the first\_signal
and y the second\_signal. It will return the value np.abs(b / np.mean(y) * 100)

If the intercept is far from zero, it indicates that the two signals
do not differ from a multiplication constant.

If a threshold is provided, returns True if the intercept is below
the specified threshold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{first\_signal: array}
\begin{quote}

The first signal array
\end{quote}

\textbf{second\_signal: array}
\begin{quote}

The second signal array
\end{quote}

\textbf{threshold: float or None}
\begin{quote}

Threshold for the intercept percent.
\end{quote}

\item[{Returns}] \leavevmode
intercept\_percent: float or boolean
\begin{quote}

If threshold is None, then the function returns the value of the intercept b, relative
to the mean value of the second\_signal
If a threshold is provided, the function returns True if the intercept value is
below the threshold.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_min\_max\_ratio() (in module fit\_checks)}

\begin{fulllineitems}
\phantomsection\label{fit_checks:fit_checks.check_min_max_ratio}\pysiglinewithargsret{\sphinxcode{fit\_checks.}\sphinxbfcode{check\_min\_max\_ratio}}{\emph{first\_signal}, \emph{second\_signal}, \emph{threshold=None}}{}
Returns the ration between minimum and maximum values (i.e. min / max).

The operation is performed for both signals and the minimum is returned. The
aim is to detect regions of large variation e.g. edges of clouds. Similar
large values will be returned when the signals are near 0, so the relative difference is
large. Consequently, this test should be used in parallel with checks e.g. about
signal to noise ratio.

If a threshold is provided, returns True if
the reltio  is above the specified threshold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{first\_signal: array}
\begin{quote}

The first signal array
\end{quote}

\textbf{second\_signal: array}
\begin{quote}

The second signal array
\end{quote}

\textbf{threshold: float or None}
\begin{quote}

Threshold for the correlation coefficient.
\end{quote}

\item[{Returns}] \leavevmode
minmax: float or boolean
\begin{quote}

If threshold is None, then the function returns the min/max ratio.
If a threshold is provided, the function returns True if the correlation value is
above the threshold.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_residuals\_not\_gaussian() (in module fit\_checks)}

\begin{fulllineitems}
\phantomsection\label{fit_checks:fit_checks.check_residuals_not_gaussian}\pysiglinewithargsret{\sphinxcode{fit\_checks.}\sphinxbfcode{check\_residuals\_not\_gaussian}}{\emph{first\_signal}, \emph{second\_signal}, \emph{threshold=None}}{}
Check if the residuals of the linear fit are not from a normal distribution.

The function uses a Shapiro-Wilk test on the residuals of a linear fit. Specifically,
the function performs a linear fit to the data, assuming y = ax, and then calculates the residuals
r = y - ax. It will return the p value of the Shapiro-Wilk test on the residuals.

If a threshold is provided, returns True if the p value is below the specified threshold, i.e. if
the residuals are probably not gaussian.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{first\_signal: array}
\begin{quote}

The first signal array
\end{quote}

\textbf{second\_signal: array}
\begin{quote}

The second signal array
\end{quote}

\textbf{threshold: float or None}
\begin{quote}

Threshold for the Shapiro-Wilk p-value.
\end{quote}

\item[{Returns}] \leavevmode
p\_value: float or boolean
\begin{quote}

If threshold is None, then the function returns the p-value of the Shapiro-Wilk test on the residuals.
If a threshold is provided, the function returns True if p-value is below the threshold.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{sliding\_check\_correlation() (in module fit\_checks)}

\begin{fulllineitems}
\phantomsection\label{fit_checks:fit_checks.sliding_check_correlation}\pysiglinewithargsret{\sphinxcode{fit\_checks.}\sphinxbfcode{sliding\_check\_correlation}}{\emph{first\_signal}, \emph{second\_signal}, \emph{window\_length=11}, \emph{threshold=None}}{}
Returns the sliding correlation coefficient between the two signals.

If a threshold is provided, returns True if
the correlation is above the specified threshold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{first\_signal: array}
\begin{quote}

The first signal array
\end{quote}

\textbf{second\_signal: array}
\begin{quote}

The second signal array
\end{quote}

\textbf{window\_length: int}
\begin{quote}

The length of the window. It should be an odd number.
\end{quote}

\textbf{threshold: float or None}
\begin{quote}

Threshold for the correlation coefficient.
\end{quote}

\item[{Returns}] \leavevmode
correlation: float or boolean
\begin{quote}

If threshold is None, then the function returns an the correlation coefficient.
If a threshold is provided, the function returns True if the correlation value is
above the threshold.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{sliding\_check\_linear\_fit\_intercept() (in module fit\_checks)}

\begin{fulllineitems}
\phantomsection\label{fit_checks:fit_checks.sliding_check_linear_fit_intercept}\pysiglinewithargsret{\sphinxcode{fit\_checks.}\sphinxbfcode{sliding\_check\_linear\_fit\_intercept}}{\emph{first\_signal}, \emph{second\_signal}, \emph{window\_length=11}, \emph{threshold=None}}{}
Check if the intercept of a linear fit is near zero.

Performs a linear fit to the data, assuming y = ax + b, with x the first\_signal
and y the second\_signal. It will return the value np.abs(b / np.mean(y) * 100)

The sliding function

If a threshold is provided, returns True if the intercept is below
the specified threshold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{first\_signal: array}
\begin{quote}

The first signal array
\end{quote}

\textbf{second\_signal: array}
\begin{quote}

The second signal array
\end{quote}

\textbf{window\_length: int}
\begin{quote}

The length of the window. It should be an odd number.
\end{quote}

\textbf{threshold: float or None}
\begin{quote}

Threshold for the intercept percent.
\end{quote}

\item[{Returns}] \leavevmode
intercepts: float or boolean
\begin{quote}

If threshold is None, then the function returns the \% value of the intercept b, relative
to the mean value of the second\_signal
If a threshold is provided, the function returns True if the intercept value is
below the threshold.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{sliding\_check\_min\_max\_ratio() (in module fit\_checks)}

\begin{fulllineitems}
\phantomsection\label{fit_checks:fit_checks.sliding_check_min_max_ratio}\pysiglinewithargsret{\sphinxcode{fit\_checks.}\sphinxbfcode{sliding\_check\_min\_max\_ratio}}{\emph{first\_signal}, \emph{second\_signal}, \emph{window\_length=11}, \emph{threshold=None}}{}
Returns the sliding min/max ratio for both signals

If a threshold is provided, returns True if
the min/max ratio is above the specified threshold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{first\_signal: array}
\begin{quote}

The first signal array
\end{quote}

\textbf{second\_signal: array}
\begin{quote}

The second signal array
\end{quote}

\textbf{window\_length: int}
\begin{quote}

The length of the window. It should be an odd number.
\end{quote}

\textbf{threshold: float or None}
\begin{quote}

Threshold for the correlation coefficient.
\end{quote}

\item[{Returns}] \leavevmode
correlation: float or boolean
\begin{quote}

If threshold is None, then the function returns an the correlation coefficient.
If a threshold is provided, the function returns True if the correlation value is
above the threshold.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{sliding\_check\_residuals\_not\_gaussian() (in module fit\_checks)}

\begin{fulllineitems}
\phantomsection\label{fit_checks:fit_checks.sliding_check_residuals_not_gaussian}\pysiglinewithargsret{\sphinxcode{fit\_checks.}\sphinxbfcode{sliding\_check\_residuals\_not\_gaussian}}{\emph{first\_signal}, \emph{second\_signal}, \emph{window\_length}, \emph{threshold=None}}{}
Check if the residuals of the linear fit are not from a normal distribution.

The function uses a Shapiro-Wilk test on the residuals of a linear fit. Specifically,
the function performs a linear fit to the data, assuming y = ax, and then calculates the residuals
r = y - ax. It will return the p value of the Shapiro-Wilk test on the residuals.

If a threshold is provided, returns True if the p value is below the specified threshold, i.e. if
the residuals are probably not gaussian.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{first\_signal: array}
\begin{quote}

The first signal array
\end{quote}

\textbf{second\_signal: array}
\begin{quote}

The second signal array
\end{quote}

\textbf{window\_length: int}
\begin{quote}

The length of the window. It should be an odd number.
\end{quote}

\textbf{threshold: float or None}
\begin{quote}

Threshold for the Shapiro-Wilk p-value.
\end{quote}

\item[{Returns}] \leavevmode
p\_value: array
\begin{quote}

If threshold is None, then the function returns the p-value of the Shapiro-Wilk test on the residuals.
If a threshold is provided, the function returns True if p-value is below the threshold.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Raman retrievals}
\label{raman:raman-retrievals}\label{raman::doc}\label{raman:module-raman_retrievals}\index{raman\_retrievals (module)}
Retrievals of backscatter and extinction based on Raman measurements

\begin{notice}{warning}{Warning:}
These functions have not been tested!
\end{notice}
\index{raman\_extinction() (in module raman\_retrievals)}

\begin{fulllineitems}
\phantomsection\label{raman:raman_retrievals.raman_extinction}\pysiglinewithargsret{\sphinxcode{raman\_retrievals.}\sphinxbfcode{raman\_extinction}}{\emph{signal}, \emph{dz}, \emph{emission\_wavelength}, \emph{raman\_wavelength}, \emph{angstrom\_aerosol}, \emph{temperature}, \emph{pressure}, \emph{window\_size}, \emph{order}, \emph{C=385.0}, \emph{rh=0.0}, \emph{reference\_molecule\_fraction=0.78084}}{}
Calculates the aerosol extinction coefficient based on pre-processed Raman signals and molecular profiles.

The derivative is calculated using a Savitzky-Golay filter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal} : (M,) array
\begin{quote}

The range\_corrected molecular signal. Should be 1D array of size M.
\end{quote}

\textbf{dz} : float
\begin{quote}

Altitude step, used in the derivative {[}m{]}
\end{quote}

\textbf{emission\_wavelength, raman\_wavelength} : float
\begin{quote}

The emission and detection wavelengths {[}nm{]}
\end{quote}

\textbf{angstrom\_aerosol} : float
\begin{quote}

The aerosol Angstrom exponent.
\end{quote}

\textbf{temperature} : (M,) array
\begin{quote}

Atmospheric temperature profile, same shape as the lidar signal {[}Kelvin{]}
\end{quote}

\textbf{pressure} : (M,) array
\begin{quote}

Atmospheric pressure profile, same shape as the lidar signal {[}hPa{]}
\end{quote}

\textbf{window\_size} : int
\begin{quote}

the length of the smoothing window. Must be an odd integer number.
\end{quote}

\textbf{order} : int
\begin{quote}

The order of the polynomial used in the filtering.
Must be less then \sphinxtitleref{window\_size} - 1.
\end{quote}

\textbf{C: float}
\begin{quote}

CO2 concentration {[}ppmv{]}.
\end{quote}

\textbf{rh: float}
\begin{quote}

Relative humidity from 0 to 100 {[}\%{]}
\end{quote}

\textbf{reference\_molecule\_fraction} : float
\begin{quote}

The fraction of the reference molecule (N2, O2, ...) as part of the atmosphere.
E.g. 0.78084 for N2, 0.20946 for O2.
\end{quote}

\item[{Returns}] \leavevmode
alpha\_aer: arrays
\begin{quote}

The aerosol backscatter coefficient {[}m-1 sr-1{]}
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{retrieve\_raman\_extinction() (in module raman\_retrievals)}

\begin{fulllineitems}
\phantomsection\label{raman:raman_retrievals.retrieve_raman_extinction}\pysiglinewithargsret{\sphinxcode{raman\_retrievals.}\sphinxbfcode{retrieve\_raman\_extinction}}{\emph{signal}, \emph{dz}, \emph{emission\_wavelength}, \emph{raman\_wavelength}, \emph{alpha\_molecular\_emission}, \emph{alpha\_molecular\_raman}, \emph{angstrom\_aerosol}, \emph{number\_density}, \emph{window\_size}, \emph{order}}{}
Calculates the aerosol extinction coefficient based on pre-processed Raman signals and molecular profiles.

The derivative is calculated using a Savitzky-Golay filter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal} : (M,) array
\begin{quote}

The range\_corrected molecular signal. Should be 1D array of size M.
\end{quote}

\textbf{dz} : float
\begin{quote}

Altitude step, used in the derivative {[}m{]}
\end{quote}

\textbf{emission\_wavelength, raman\_wavelength} : float
\begin{quote}

The emission and detection wavelength {[}nm{]}
\end{quote}

\textbf{alpha\_molecular\_emission, alpha\_molecular\_raman} : (M,) array
\begin{quote}

The molecular extinction coefficient at each point of the signal profile for emission and raman wavelength.
\end{quote}

\textbf{number\_density} : (M,) array
\begin{quote}

The number density of the scattering molecule. E.g. the number density of N2 particles for typical Raman systems.
\end{quote}

\textbf{angstrom\_aerosol: float}
\begin{quote}

The aerosol Angstrom exponent.
\end{quote}

\textbf{window\_size} : int
\begin{quote}

the length of the smoothing window. Must be an odd integer number.
\end{quote}

\textbf{order} : int
\begin{quote}

The order of the polynomial used in the filtering.
Must be less then \sphinxtitleref{window\_size} - 1.
\end{quote}

\item[{Returns}] \leavevmode
alpha\_aer: arrays
\begin{quote}

The aerosol backscatter coefficient {[}m-1 sr-1{]}
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Linear depolarization estimation}
\label{depolarization:linear-depolarization-estimation}\label{depolarization::doc}\label{depolarization:module-depolarization}\index{depolarization (module)}
Functions for calculating the linear volume depolarization ratio.
\index{calibration\_constant\_cross\_parallel\_profile() (in module depolarization)}

\begin{fulllineitems}
\phantomsection\label{depolarization:depolarization.calibration_constant_cross_parallel_profile}\pysiglinewithargsret{\sphinxcode{depolarization.}\sphinxbfcode{calibration\_constant\_cross\_parallel\_profile}}{\emph{signal\_cross\_plus45}, \emph{signal\_cross\_minus45}, \emph{signal\_parallel\_plus45}, \emph{signal\_parallel\_minus45}, \emph{t\_cross}, \emph{t\_parallel}, \emph{r\_cross}, \emph{r\_parallel}}{}
Calculate the calibration constant in a lidar system that is able to 
detect the cross-to-parallel depolarization ratio.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal\_cross\_plus45: vector}
\begin{quote}

The input vertical profile from the cross channel. Calibrator angle phi=45.
\end{quote}

\textbf{signal\_parallel\_plus45: vector}
\begin{quote}

The input vertical profile from the total channel. Calibrator angle phi=45.
\end{quote}

\textbf{signal\_cross\_minus45: vector}
\begin{quote}

The input vertical profile from the cross channel. Calibrator angle phi=-45.
\end{quote}

\textbf{signal\_parallel\_minus45: vector}
\begin{quote}

The input vertical profile from the total channel. Calibrator angle phi=-45.
\end{quote}

\textbf{t\_cross: float}
\begin{quote}

Transmittance of cross component through transmitted path.
\end{quote}

\textbf{t\_parallel: float}
\begin{quote}

Transmittance of parallel component through transmitted path.
\end{quote}

\textbf{r\_cross: float}
\begin{quote}

Transmittance of cross component through reflected path.
\end{quote}

\textbf{r\_parallel: float}
\begin{quote}

Transmittance of parallel component through reflected path.
\end{quote}

\item[{Returns}] \leavevmode
v\_star\_mean: float
\begin{quote}

Calibration constant's mean value (vertical axis).
\end{quote}

v\_star\_sem: float
\begin{quote}

Calibration constant's standard error of the mean (vertical axis).
\end{quote}

\end{description}\end{quote}
\paragraph{References}

Freudenthaler, V. et al. Depolarization ratio profiling at several wavelengths in pure
Saharan dust during SAMUM 2006. Tellus, 61B, 165-179 (2008)

\end{fulllineitems}

\index{calibration\_constant\_cross\_total\_profile() (in module depolarization)}

\begin{fulllineitems}
\phantomsection\label{depolarization:depolarization.calibration_constant_cross_total_profile}\pysiglinewithargsret{\sphinxcode{depolarization.}\sphinxbfcode{calibration\_constant\_cross\_total\_profile}}{\emph{signal\_cross\_plus45}, \emph{signal\_cross\_minus45}, \emph{signal\_total\_plus45}, \emph{signal\_total\_minus45}, \emph{r\_cross}, \emph{r\_total}}{}
Calculate the calibration constant profile, in a lidar system that is able
to detect the cross-to-total depolarization ratio.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal\_cross\_plus45: vector}
\begin{quote}

The input vertical profile from the cross channel. Calibrator angle phi=45.
\end{quote}

\textbf{signal\_total\_plus45: array}
\begin{quote}

The input vertical profile from the total channel. Calibrator angle phi=45.
\end{quote}

\textbf{signal\_cross\_minus45: vector}
\begin{quote}

The input vertical profile from the cross channel. Calibrator angle phi=-45.
\end{quote}

\textbf{signal\_total\_minus45: vector}
\begin{quote}

The input vertical profile from the total channel. Calibrator angle phi=-45.
\end{quote}

\textbf{r\_cross: float}
\begin{quote}

The transmission ratio of the cross channel (Rc).
\end{quote}

\textbf{r\_total: float}
\begin{quote}

The transmission ratio of the total channel (Rt).
\end{quote}

\item[{Returns}] \leavevmode
c\_profile: vector
\begin{quote}

The vertical profile of the calibration constant.
\end{quote}

\end{description}\end{quote}
\paragraph{References}

Engelmann, R. et al. The automated multiwavelength Raman polarization and water-vapor lidar
Polly XT: the neXT generation. Atmos. Meas. Tech., 9, 1767-1784 (2016)

\end{fulllineitems}

\index{calibration\_constant\_value() (in module depolarization)}

\begin{fulllineitems}
\phantomsection\label{depolarization:depolarization.calibration_constant_value}\pysiglinewithargsret{\sphinxcode{depolarization.}\sphinxbfcode{calibration\_constant\_value}}{\emph{calibration\_constant\_profile}, \emph{first\_bin}, \emph{bin\_length}, \emph{lower\_limit}, \emph{upper\_limit}}{}
Calculate the mean calibration constant and its standard error of the mean,
from the calibration constant profile.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{c\_profile: vector}
\begin{quote}

The vertical profile of the calibration constant.
\end{quote}

\textbf{first\_bin: integer}
\begin{quote}

The first bin of the system.
\end{quote}

\textbf{bin\_length: float}
\begin{quote}

The length of each bin. (in meters)
\end{quote}

\textbf{lower\_limit: float}
\begin{quote}

The lower vertical limit for the calculation. (in meters)
\end{quote}

\textbf{upper\_limit: float}
\begin{quote}

The lower vertical limit for the calculation. (in meters)
\end{quote}

\item[{Returns}] \leavevmode
c\_mean: float
\begin{quote}

Calibration constant's mean value (vertical axis).
\end{quote}

c\_sem: float
\begin{quote}

Calibration constant's standard error of the mean (vertical axis).
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{particle\_depolarization() (in module depolarization)}

\begin{fulllineitems}
\phantomsection\label{depolarization:depolarization.particle_depolarization}\pysiglinewithargsret{\sphinxcode{depolarization.}\sphinxbfcode{particle\_depolarization}}{\emph{delta\_m}, \emph{delta\_v}, \emph{molecular\_backscatter}, \emph{particle\_backscatter}}{}
Calculate the linear particle depolarization ratio.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{delta\_m: vector}
\begin{quote}

The linear molecular depolarization ratio.
\end{quote}

\textbf{delta\_v: vector}
\begin{quote}

The linear volume depolarization ratio.
\end{quote}

\textbf{molecular\_backscatter: vector}
\begin{quote}

The molecular component of the total backscatter coefficient.
\end{quote}

\textbf{particle\_backscatter: vector}
\begin{quote}

The particle component of the total backscatter coefficient.
\end{quote}

\item[{Returns}] \leavevmode
delta\_p: vector
\begin{quote}

The linear particle depolarization ratio.
\end{quote}

\end{description}\end{quote}
\paragraph{References}

Freudenthaler, V. et al. Depolarization ratio profiling at several wavelengths in pure
Saharan dust during SAMUM 2006. Tellus, 61B, 165-179 (2008)

\end{fulllineitems}

\index{volume\_depolarization\_cross\_parallel() (in module depolarization)}

\begin{fulllineitems}
\phantomsection\label{depolarization:depolarization.volume_depolarization_cross_parallel}\pysiglinewithargsret{\sphinxcode{depolarization.}\sphinxbfcode{volume\_depolarization\_cross\_parallel}}{\emph{signal\_cross}, \emph{signal\_parallel}, \emph{t\_cross}, \emph{t\_parallel}, \emph{r\_cross}, \emph{r\_parallel}, \emph{v\_star}}{}
Calculate the linear volume depolarization ratio in a lidar system that is
able to detect the cross-to-parallel depolarization ratio.
The calibration factor from the delta-90 calibration is being used.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal\_cross: vector}
\begin{quote}

The input vertical profile from the cross channel. Normal measurement (phi=0).
\end{quote}

\textbf{signal\_parallel: vector}
\begin{quote}

The input vertical profile from the parallel channel. Normal measurement (phi=0).
\end{quote}

\textbf{t\_cross: float}
\begin{quote}

Transmittance of cross component through transmitted path.
\end{quote}

\textbf{t\_parallel: float}
\begin{quote}

Transmittance of parallel component through transmitted path.
\end{quote}

\textbf{r\_cross: float}
\begin{quote}

Transmittance of cross component through reflected path.
\end{quote}

\textbf{r\_parallel: float}
\begin{quote}

Transmittance of parallel component through reflected path.
\end{quote}

\textbf{v\_star: float}
\begin{quote}

The calibration constant.
\end{quote}

\item[{Returns}] \leavevmode
delta\_v: vector
\begin{quote}

The linear volume depolarization.
\end{quote}

\end{description}\end{quote}
\paragraph{References}

Freudenthaler, V. et al. Depolarization ratio profiling at several wavelengths in pure
Saharan dust during SAMUM 2006. Tellus, 61B, 165-179 (2008)

\end{fulllineitems}

\index{volume\_depolarization\_cross\_total() (in module depolarization)}

\begin{fulllineitems}
\phantomsection\label{depolarization:depolarization.volume_depolarization_cross_total}\pysiglinewithargsret{\sphinxcode{depolarization.}\sphinxbfcode{volume\_depolarization\_cross\_total}}{\emph{signal\_cross}, \emph{signal\_total}, \emph{r\_cross}, \emph{r\_total}, \emph{c}}{}
Calculate the linear volume depolarization ratio in a lidar system that is
able to detect the cross-to-total depolarization ratio.
The calibration factor from the delta-90 calibration is being used.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal\_cross: vector}
\begin{quote}

The input vertical profile from the cross channel. Normal measurement (phi=0).
\end{quote}

\textbf{signal\_total: vector}
\begin{quote}

The input vertical profile from the total channel. Normal measurement (phi=0).
\end{quote}

\textbf{r\_cross: float}
\begin{quote}

The transmission ratio of the cross channel (Rc).
\end{quote}

\textbf{r\_total: float}
\begin{quote}

The transmission ratio of the total channel (Rt).
\end{quote}

\textbf{c: float}
\begin{quote}

The calibration constant.
\end{quote}

\item[{Returns}] \leavevmode
delta\_v: vector
\begin{quote}

The linear volume depolarization.
\end{quote}

\end{description}\end{quote}
\paragraph{References}

Engelmann, R. et al. The automated multiwavelength Raman polarization and water-vapor
lidar Polly XT: the neXT generation. Atmos. Meas. Tech., 9, 1767-1784 (2016)

\end{fulllineitems}



\chapter{HSRL retrieval functions}
\label{hsrl_retrieval:module-hsrl_retrieval}\label{hsrl_retrieval:hsrl-retrieval-functions}\label{hsrl_retrieval::doc}\index{hsrl\_retrieval (module)}
Routines to process High Spectral Resolution Lidar (HSRL) signals.

\begin{notice}{note}{Todo}

Fix molecular scattering calculations. Currently the bacskcatter and extinction
calculations are done using slightly different formulas.

Fix cabannes line calculations.
\end{notice}
\index{aerosol\_backscatter() (in module hsrl\_retrieval)}

\begin{fulllineitems}
\phantomsection\label{hsrl_retrieval:hsrl_retrieval.aerosol_backscatter}\pysiglinewithargsret{\sphinxcode{hsrl\_retrieval.}\sphinxbfcode{aerosol\_backscatter}}{\emph{signal\_aerosol}, \emph{signal\_mol}, \emph{temperature}, \emph{pressure}, \emph{wavelength}, \emph{C=385.0}, \emph{p\_e=0.0}}{}
Calculates the aerosol backscatter coefficient.

The profiles of temperature and pressure are used, together with CO2 and 
water vaport concentrations, to calculate the scattering properties of 
the molecular atmosphere.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal\_aerosol: array}
\begin{quote}

The range-corrected aerosol photons arriving at the lidar.
\end{quote}

\textbf{signal\_mol: array}
\begin{quote}

The range\_corrected molecular photons arriving at the lidar
\end{quote}

\textbf{temperature: array}
\begin{quote}

The temperature profile for each measurement point {[}Kelvin{]}
\end{quote}

\textbf{pressure: array}
\begin{quote}

The pressure profile for each measurement point {[}hPa{]}
\end{quote}

\textbf{wavelength: float}
\begin{quote}

Emission wavelength {[}nm{]}
\end{quote}

\textbf{C: float}
\begin{quote}

CO2 concentration {[}ppmv{]}.
\end{quote}

\textbf{p\_e: float}
\begin{quote}

water-vapor pressure {[}hPa{]}
\end{quote}

\item[{Returns}] \leavevmode
beta\_aer: array
\begin{quote}

The aerosol backscatter coefficient {[}m-1 sr-1{]}
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{aerosol\_extinction() (in module hsrl\_retrieval)}

\begin{fulllineitems}
\phantomsection\label{hsrl_retrieval:hsrl_retrieval.aerosol_extinction}\pysiglinewithargsret{\sphinxcode{hsrl\_retrieval.}\sphinxbfcode{aerosol\_extinction}}{\emph{signal}, \emph{dz}, \emph{temperature}, \emph{pressure}, \emph{wavelength}, \emph{C=385.0}, \emph{p\_e=0.0}, \emph{window\_size=11}, \emph{order=2}}{}
Calculates the aerosol extinction coefficient.

The profiles of temperature and pressure are used, together with CO2 and 
water vaport concentrations, to calculate the scattering properties of 
the molecular atmosphere.

The derivative is calculated using a Savitzky-Golay filter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal:}
\begin{quote}

The range corrected molecular photons arriving at the lidar
\end{quote}

\textbf{dz: float}
\begin{quote}

Altitude step, used in the derivative {[}m{]}
\end{quote}

\textbf{temperature: array}
\begin{quote}

The temperature profile for each measurement point {[}Kelvin{]}
\end{quote}

\textbf{pressure: array}
\begin{quote}

The pressure profile for each measurement point {[}hPa{]}
\end{quote}

\textbf{wavelength: float}
\begin{quote}

Emission wavelength {[}nm{]}
\end{quote}

\textbf{C: float}
\begin{quote}

CO2 concentration {[}ppmv{]}.
\end{quote}

\textbf{p\_e: float}
\begin{quote}

water-vapor pressure {[}hPa{]}
\end{quote}

\textbf{window\_size} : int
\begin{quote}

the length of the smoothing window. Must be an odd integer number.
\end{quote}

\textbf{order} : int
\begin{quote}

the order of the polynomial used in the filtering.
Must be less then \sphinxtitleref{window\_size} - 1.
\end{quote}

\item[{Returns}] \leavevmode
alpha\_aer: arrays
\begin{quote}

The aerosol backscatter coefficient {[}m-1 sr-1{]}
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{hsr\_calibration\_constant() (in module hsrl\_retrieval)}

\begin{fulllineitems}
\phantomsection\label{hsrl_retrieval:hsrl_retrieval.hsr_calibration_constant}\pysiglinewithargsret{\sphinxcode{hsrl\_retrieval.}\sphinxbfcode{hsr\_calibration\_constant}}{\emph{signal\_total}, \emph{signal\_mol}, \emph{Cmm}, \emph{Cmt}, \emph{Cam}, \emph{Cat}, \emph{scattering\_ratio=0}}{}
Calculate the calibration constant for two HSR channels.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal\_total: array}
\begin{quote}

The signal of the total channel.
\end{quote}

\textbf{signal\_mol: array}
\begin{quote}

The signal in the molecular channel
\end{quote}

\textbf{Cmm, Cmt, Cam, Cat: float or array}
\begin{quote}

The cross-talk coefficients for the two channels. Cmm-\textgreater{}Molecular signal to molecular channel, etc.
\end{quote}

\textbf{scattering\_ratio: float}
\begin{quote}

The ratio of aerosol to molecular backscatter at the specific altitude.
\end{quote}

\item[{Returns}] \leavevmode
calibration\_constant: float
\begin{quote}

The relative calibration constant eta\_rho between the two channels (total / molecular).
\end{quote}

calibration\_error: float
\begin{quote}

The uncertainty (standard deviation of the mean) for the constant.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{retrieve\_channel() (in module hsrl\_retrieval)}

\begin{fulllineitems}
\phantomsection\label{hsrl_retrieval:hsrl_retrieval.retrieve_channel}\pysiglinewithargsret{\sphinxcode{hsrl\_retrieval.}\sphinxbfcode{retrieve\_channel}}{\emph{signal\_total}, \emph{signal\_mol}, \emph{z}, \emph{temperature}, \emph{pressure}, \emph{Cmm}, \emph{Cmt}, \emph{Cam}, \emph{Cat}, \emph{wavelength}, \emph{cal\_idx\_min=800}, \emph{cal\_idx\_max=1000}, \emph{eta\_rho=None}, \emph{window\_size=11}, \emph{order=2}}{}
Retrieve the optical parameters from channel data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal\_total, signal\_mol: array}
\begin{quote}

The total and molecular signals received from the system
\end{quote}

\textbf{z: array}
\begin{quote}

The altitude of each range bin {[}m{]}
\end{quote}

\textbf{temperature: array}
\begin{quote}

The temperature profile for each measurement point {[}Kelvin{]}
\end{quote}

\textbf{pressure: array}
\begin{quote}

The pressure profile for each measurement point {[}hPa{]}
\end{quote}

\textbf{Cmm, Cmt, Cam, Cat: float or array}
\begin{quote}

The cross-talk coefficients for the two channels. Cmm-\textgreater{}Molecular signal 
to molecular channel, etc.
\end{quote}

\textbf{wavelength: float}
\begin{quote}

Emission wavelength {[}nm{]}
\end{quote}

\textbf{cal\_idx\_min, cal\_idx\_max: int}
\begin{quote}

Array index for the calibration region
\end{quote}

\textbf{eta\_rho: float}
\begin{quote}

Calibration constant. If provided, the calibration indexes are ignored.
\end{quote}

\textbf{window\_size} : int
\begin{quote}

the length of the smoothing window. Must be an odd integer number.
\end{quote}

\textbf{order} : int
\begin{quote}

the order of the polynomial used in the filtering.
Must be less then \sphinxtitleref{window\_size} - 1.
\end{quote}

\item[{Returns}] \leavevmode
alpha\_aer, beta\_aer: array
\begin{quote}

Aerosol extinction coefficients {[}m-1{]} and bacsckatter coefficients{[}m-1 sr-1{]}
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{signal\_unmixing() (in module hsrl\_retrieval)}

\begin{fulllineitems}
\phantomsection\label{hsrl_retrieval:hsrl_retrieval.signal_unmixing}\pysiglinewithargsret{\sphinxcode{hsrl\_retrieval.}\sphinxbfcode{signal\_unmixing}}{\emph{signal\_total}, \emph{signal\_mol}, \emph{Cmm}, \emph{Cmt}, \emph{Cam}, \emph{Cat}, \emph{calibration\_constant}}{}
Calculate the molecular and aerosol photons arriving at the lidar.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{signal\_total: array}
\begin{quote}

The signal of the total channel.
\end{quote}

\textbf{signal\_mol: array}
\begin{quote}

The signal in the molecular channel
\end{quote}

\textbf{Cmm, Cmt, Cam, Cat: float or array}
\begin{quote}

The cross-talk coefficients for the two channels. Cmm-\textgreater{}Molecular signal to molecular channel, etc.
\end{quote}

\textbf{calibration\_constant: float}
\begin{quote}

The relative calibration constant eta\_rho between the two channels (total / molecular).
\end{quote}

\item[{Returns}] \leavevmode
N\_a, N\_m: arrays
\begin{quote}

The aerosol and molecular photons arriving at the detector.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Some notes concerning Klett retrieval algorithm}
\label{klett_notes:some-notes-concerning-klett-retrieval-algorithm}\label{klett_notes::doc}

\section{Introduction}
\label{klett_notes:introduction}
Following Weitkamp, K. Lidar. p.111 (Springer, 2005), the sum of the aerosol and molecular backscatter coefficients are given by the following formula:

\(\beta_{aer}(R) + \beta_{mol}(R) = \frac{S(R) \cdot exp(-2\int_{R_{0}}^{R} [L_{aer}(r)-L_{mol}] \cdot \beta_{mol}(r) \cdot dr)}{\frac{S(R_0)}{\beta_{aer}(R_{0})+\beta_{mol}(R_0)}-2\int_{R_0}^{R}L_{aer}(r) \cdot S(r) \cdot T(r,R_0)}) \cdot dr}\)

With, \(T(r,R_0) = exp(-2\int_{R_0}^{r}[L_{aer}(r')-L_{mol}] \cdot \beta_{mol}(r') \cdot dr')\)

\(R\): distance from the source

\(R_0\) : distance between the source and the reference region

\(\beta_{aer}\): aerosol backscatter coefficient \((km^{-1} \cdot sr^{-1})\)

\(\beta_{mol}\): molecular backscatter coefficient \((km^{-1} \cdot sr^{-1})\)

\(S(R)\): range corrected signal, \(S(R)=R^2 \cdot P(R)\)

\(P\): signal due to particle and molecular scattering

\(L_{aer}\): aerosol lidar ratio (extinction-to-backscatter coefficient)

\(L_{mol}\): molecular lidar ratio

Note: All the definite integrals in the above equation, have the reference height \(R_{0}\) as their lower limit, and the requested height \(R\) as their upper limit. Interchanging the limits of definite integrals, is followed by the addition of a minus sign in front of the integral. For example, the region between \(x_{1}=2\) and \(x_{2}=5\), bounded by the graph of \(f(x)=2x\), can be equivalently expressed with the following two ways:

\(I = \int_{x_1}^{x_2}f(x) \cdot dx = \int_2^5 2x \cdot dx = [x^2]_2^5 = 5^2-2^2 = 21\)

\(I = -\int_{x_2}^{x_1}f(x) \cdot dx = \int_5^2 2x \cdot dx = [x^2]_5^2 = -(2^2-5^2) = 21\)

This basic rule is imperative for the correct analytical solution of the definite integral (i.e. when the \(f(x)\) is given). However, the nature of Lidar signals demands a strictly numerical approach to the definite integral solution, since none of the functions to be integrated is known.


\section{Klett Algorithm}
\label{klett_notes:klett-algorithm}
There are several established methods for the numerical integration. The most notable ones are the Riemann Sum, the Trapezoidal Rule, and the Simpsons Rule. The Trapezoidal Rule requires two (2) orders of magnitude less calculations than the Riemann Sum, in order to reach the same approximation accuracy, while the Simpsons Rule is almost one (1) order of magnitude more efficient that the Trapezoidal Rule.

Despite the computational efficiency of Simpsons Rule, the Trapezoidal Rule is more widely used in the Lidar community due to its formalistic simplicity. This numerical method demands the lower limit of the integral to be smaller than the upper limit, thus some adjustments in the Lidar equations are necessary.

In the case of PollyXT, the values of the requested height R are identical to the altitude intervals that the bins dictate (e.g. 7.5m/bin). Caution is needed at this point, since the reference height can either be larger (R\_0\textgreater{}R) or smaller (R\_0\textless{}R) than the requested height, depending on the selected bin for the calculation. In order for the Trapezoidal Rule to work, however, the lower limit of the integration must always be smaller than the upper limit.
Consequently, the above formula takes a different form for the numerical calculation, depending on the relative values of the reference and requested height:
\begin{itemize}
\item {} 
\(R<R_0\) :    \(\qquad ... +2 \int_{R}^{R_0}... \cdot dr \Rightarrow \sum_{R}^{R_{0}}[Trz(R,R+1)+Trz(R+2,R+3)+...+Trz(R_0-1,R_0)]\)

\item {} 
\(R>R_0\) :    \(\qquad ... -2 \int_{R_0}^{R}... \cdot dr \Rightarrow \sum_{R_0}^{R}[Trz(R_0,R_0+1)+Trz(R_0+2,R_0+3)+...+Trz(R-1,R)]\)

\end{itemize}

Where, \(Trz(x_0,x_0+1)\) is the area of each trapezoid that is produced by two consecutive bins, \(x_0\) and \(x_0+1\).


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{d}
\item {\texttt{depolarization}}, \pageref{depolarization:module-depolarization}
\indexspace
\bigletter{f}
\item {\texttt{fit\_checks}}, \pageref{fit_checks:module-fit_checks}
\indexspace
\bigletter{h}
\item {\texttt{hsrl\_retrieval}}, \pageref{hsrl_retrieval:module-hsrl_retrieval}
\indexspace
\bigletter{p}
\item {\texttt{pre\_processing}}, \pageref{pre_processing:module-pre_processing}
\indexspace
\bigletter{r}
\item {\texttt{raman\_retrievals}}, \pageref{raman:module-raman_retrievals}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
